{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"# Gatsby 블로그 만들기 1\n\n![Gatsby Thumbnail Image](./images/gatsbyCover.png)\n\n\n# 시리즈 및 연재글 작성 템플릿\n연재글을 작성할 때에는 동일 폴더에 `동일한 이름_숫자.md` 형태로 파일명을 지정한다. \n추후 Static Generation 과정에서 마지막`_`를 제외하고 동일한 이름은 연재글로 간주한다. \n연재글의 경우 우측 상단에 연관된 글에 대한 리스트를 제공한다. \n\n\n`code` block에 `라인넘버`를 표기 하기 위해서는, `prismjs`의 옵션을 변경하여 준다. \n일반적으로 `code` block에서 언어를 인지하기 위해 작은따옴표3개 뒤에 다음과 언어를 표기해 준다.\n이 언어 뒤에 중괄호`{,}`를 사용하여 강조하는 라인을 지정할 수 있다. \n```\njavascript{강조 라인1, 강조라인2}\n```\n\n다음은 일반적인 코드 블럭이다. 기본적으로 prism highlight가 적용되어 있다. \n```javascript\nconst App = () => {\n    // This is a comment!\n    return 'I am returning a string';\n}\n```\n다음은 1,3라인을 강조한 결과이다. \n```javascript{1,3}\nconst App = () => {\n    // This is a comment!\n    return 'I am returning a string';\n}\n```\n\n---\n\n# npm 패키지 설치\n\n```\nnpm install <package name>\n```\n> `install` 대신 `i`를 사용할 수 있다.  `npm -i <package name>`\n## options\n- `--save-dev` : 개발환경에서만 사용(`-D` 옵션과 동일). `npm i -D <pakcage name>`\n- `--global` : 콘솔에서 명령어 처럼 동작 (`-g` 옵션과 동일)\n\n\n\n\n# github\n\n\n```\n$ npm install gh-pages --save-dev\n```\n\n대부분의 gatsby의 theme에는 이미 적용이 `package.json` 되어 있다. \n```\n// package.json\n\"deploy\": \"gatsby build && gh-pages -d public -b master\",\n```\n\n```\n$ git remote add origin https://github.com/sjwind/sjwind.github.io.git\n$ git add .\n$ git checkout -b develop\n$ git commit -m \"first commit\"\n$ npm run deploy\n```\n\n이런 에러가 발생할 수 도 있다. \n```\nremote: Invalid username or password.\nfatal: Authentication failed for 'https://github.com/sjwind/sjwind.github.io.git/'\n```\n\n","excerpt":"Gatsby 블로그 만들기 1  시리즈 및 연재글 작성 템플릿 연재글을 작성할 때에는 동일 폴더에  형태로 파일명을 지정한다. \n추후 Static Generation…","fields":{"slug":"/gatsbyBlog_1/"},"frontmatter":{"date":"May 29, 2021","title":"개츠비(Gatsby)로 블로그 만들기 1","tags":["gatsby","blog"],"update":"May 29, 2021"}}},{"node":{"rawMarkdownBody":"\n# Online Jupyter Notebook for Python\n\n\n\n\n\n## Google Colab vs. MS Azure Notebook vs. Binder\n\n\n\nOnline 환경에서 데이터 분석을 진행할 수 있는 대표적인 플랫폼을 비교/평가 해 보았다. \n\n\n\n1) Google Colab\n\n2) MS Azure Notebook\n\n3) Binder\n\n\n\n다양한 측면에서 비교를 할 수 있지만, 진정으로 크리티컬한 부분에서 놓칠 수 없는 비교점이 있다. \n\n\n\n\n\n\n\n## Google Colab\n\n\n\n제공되는 리소스는 ```2 CPU, 12G Mem 할당``` 으로 상당히 준수하다. 게다가 GPU를 제공해 주고 있어서, GPU 모드로 ML 연산을 계산할 수 있다. \n\n\n\nGoogle Colab에서 제공하는 리소스 스펙\n\nCPU 스펙\n\n```python\n!cat /proc/cpuinfo\n```\n\n```python\nprocessor\t: 0\nvendor_id\t: GenuineIntel\ncpu family\t: 6\nmodel\t\t: 79\nmodel name\t: Intel(R) Xeon(R) CPU @ 2.20GHz\nstepping\t: 0\nmicrocode\t: 0x1\ncpu MHz\t\t: 2200.000\ncache size\t: 56320 KB\n```\n\nMemory 스펙\n\n```python\n!free -h\n```\n\n```python\n              total        used        free      shared  buff/cache   available\nMem:            12G        3.0G        7.4G        908K        2.3G         11G\nSwap:            0B          0B          0B\n```\n\n\n\n\n\n\n\n### 장점\n\n웹환경에서 실행하여줌에도 불구하고, GPU를 지원해줌\n\nML을 구동시키기에 적당함\n\n\n\n### 단점\n\nUI가 몹시 레거시함\n\n\n\n\n\n![image-20200515152247703](/Users/audit01/Library/Application Support/typora-user-images/image-20200515152247703.png)\n\n개인차이가 있을 수 있겠으나, UI 좀 덜 아름답다. 뭔가 과거의 파워빌더(PowerBuilder)를 보는 느낌이랄까?\n\n\n\n![img](https://k.kakaocdn.net/dn/ca9bkW/btqEcnRjWTI/KRiP5gdMZI9ILBK8KEBDF0/img.png)\n\n실행할 때 마다 차이가 존재한다. 2~3번째 실행 할 때는 1.83초\n\n\n\n\n\n## Microsoft Azure Notebook\n\n\n\nMS Azure Notebook의 제공되는 리소스의 스펙\n\n```python\n!cat /proc/cpuinfo\n```\n\n```python\nprocessor\t: 0\nvendor_id\t: GenuineIntel\ncpu family\t: 6\nmodel\t\t: 79\nmodel name\t: Intel(R) Xeon(R) CPU E5-2673 v4 @ 2.30GHz\nstepping\t: 1\nmicrocode\t: 0xffffffff\ncpu MHz\t\t: 2294.689\ncache size\t: 51200 KB\n```\n\n\n\n```python\n!free -h\n```\n\n```python\n              total        used        free      shared  buff/cache   available\nMem:           3.8G        568M        3.1G         17M        198M        3.0G\nSwap:            0B          0B          0B\n```\n\n\n\n\n\n\n\n### 장점\n\nUI 측면에서 Jupiter Notebook 그대로를 사용하고 익숙할 뿐만아니라, UI의 편의성과 활용성이 더욱 사용하기 좋음\n\nPython 버전별로 커널을 생성하기에 편리하며, Python 외 R 등 환경도 잘 디플로이 되어 있음\n\n다양한 강좌들을 포함하고 있어서, 공부하는데 많은 도움이 됨\n\n\n\n### 단점\n\n파일 접근 할 때 속도가 많이 느림.\n\n\n\n\n\n\n\n\n\n![img](https://k.kakaocdn.net/dn/eqquwR/btqEdw7BsC4/0FUvpp7iezQhnC2p6ejoRK/img.png)\n\n두번째 및 3번째 실행 시 15.37초\n\n\n\n\n\n\n\n## Binder\n\n\n\n\n\n자체적으로 notebook을 작성하여 사용하는 방식이 아닌, GitHub에 있는 Repository를 가져와 서 실행 시켜주는 방식이다. \n\n\n\n\n\n![img](https://mybinder.org/static/logo.svg?v=f9f0d927b67cc9dc99d788c822ca21c0)\n\n\n\n![image-20200515153550284](/Users/audit01/Library/Application Support/typora-user-images/image-20200515153550284.png)\n\n\n\n\n\n\n\n\n\n```python\n!cat /proc/cpuinfo\n```\n\n```python\nprocessor\t: 71\nvendor_id\t: GenuineIntel\ncpu family\t: 6\nmodel\t\t: 85\nmodel name\t: Intel(R) Xeon(R) Gold 6140 CPU @ 2.30GHz\nstepping\t: 4\nmicrocode\t: 0x2000064\ncpu MHz\t\t: 1000.027\ncache size\t: 25344 KB\n```\n\n\n\n\n\n\n\nMemory 스펙\n\n```python\n!free -h\n```\n\n```python\n              total        used        free      shared  buff/cache   available\nMem:           754G         52G        101G         15M        600G        705G\nSwap:            0B          0B          0B\n```\n\n\n\n\n\n\n\n## GitPod\n\n\n\n\n\n\n\n\n\n\n\n\n\nCPU 스펙\n\n```python\n!cat /proc/cpuinfo\n```\n\n```python\nprocessor       : 15\nvendor_id       : GenuineIntel\ncpu family      : 6\nmodel           : 79\nmodel name      : Intel(R) Xeon(R) CPU @ 2.20GHz\nstepping        : 0\nmicrocode       : 0x1\ncpu MHz         : 2200.000\ncache size      : 56320 KB\n```\n\nM\n\n\n\nMemory 스펙\n\n```python\n!free -h\n```\n\n```python\n              total        used        free      shared  buff/cache   available\nMem:           58Gi       8.3Gi        23Gi       4.0Mi        27Gi        51Gi\nSwap:            0B          0B          0B\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","excerpt":"Online Jupyter Notebook for Python Google Colab vs. MS Azure Notebook vs. Binder Online 환경에서 데이터 분석을 진행할 수 있는 대표적인 플랫폼을 비교/평가 해 보았다.  Google…","fields":{"slug":"/Online Jupyter Notebook for Python/"},"frontmatter":{"date":"May 29, 2021","title":"Online Jupyter Notebook for Python","tags":["jupyter notebook","python"],"update":"May 29, 2021"}}},{"node":{"rawMarkdownBody":"\n# 컴.알.못 와이프, 블로거로 키우기 - 초보 블로거 따라하기 스텝 바이 스텝\n\n\n\n### *필자의 와이프는 정말 최고수준의 <u>컴.알.못.</u>이다. 네이버 검색도 잘 못하고, 웹사이트도 북마크 해둔 것만 들어간다.*\n\n사실, 블로그와 컴.알.못은 아무런 관련이 없다. 오히려 IT와 컴퓨터를 모르는 사람이 더 감각 있다는 것이 필자의 느낀점이라고나 할까? ***컴.알.못.의 문제점은***, 블로그에 대한 초기 설정들, 서치콘솔 등록들, 그리고 블로그 작성할 때 에디터와 그림편집 등을 빠르게 할 수 없다는 게 문제 이긴 하다. 그러나, 이러한 부분은 개발자출신인 남편이 얼마든지 커버할 수 있다.  개인적인 느낌은 필자보다 와이프가 블로깅에 더욱 능력이 있을 것이라는 판단이다. (이 판단은 오산이라는 것을 나중에 알게 되었어 ㅜ_ㅜ)\n\n>  사실은 블로거로 키워서 내 대신에 일을 좀 시켜보려는 원대한 계획(?)이라고 할 수 있다. \n\n와이프의 블로그 시작과 함께, 집에서 사용하던 Windows 데스크탑 메인보드가 사망하였다. ㅜ_ㅜ 필자는 Windows 노트북1, 맥북프로 2대의 총 3대의 노트북이 있어서, 그중에 맥북프로1을 와이프에게 인계하려 했으나, 컴.알.못 와이프께서 맥북을 도저히 못사용하시겠다고 말씀하셨다.  이번달이 와이프 탄신일, 와이프의 블로깅 시작, 데스크탑 부재의 3가지 환경을 고려하여 `와.이.프. 전용 노트북`을 큰맘 먹고 하나 질러 주었다. \n\n> 데스크탑은 부재한 상황에서 노트북만 책상위에 굴러다니는 형국이다.\n\n어쨌든 이러한 이유로 와이프에게 반 강제적으로 **컴.알.못 와이프를 블로거**로 키우기로 하였다. 이 과정에서 당연히 알겠거니 하며 건너갔던 부분을 몇몇 발견하게 되었고, 비슷한 곤란을 겪는 사람들이 있을 것 같아서 진행과정을 기록해 보고자 한다. \n\n\n\n## STEP 1. 일단 블로그를 만든다. \n\n와이프 설득만 몇달 하다가 안되겠구나 싶어서, 강제적으로 블로그 계정 등록부터 시켰다. 다른것 고민할 것 없이 그냥 티스토리(Tistory) 계정을 만들어 주었다. 많은 분들이 비슷한 과정을 겪었을 테지만, 이름 정하는 것이 가장 어려웠다. 계정 이름 정하는 것이 제일 어렵더이다. `개구쟁이 아이`의 방해와 역경을 이겨내고, 동일한 계정/블로그 이름을 피해서, 맘에드는 것을 정하여 블로그 계정을 완성하는 (1 Page)를 넘어가는데 **첫째날** 이 지나가 버렸다. 벌써 힘이 빠진다.\n\n> 시작이 반이다. 일단 시작은 했다. 에효~\n>\n> 그래도 설득만 하던 시절을 생각하면 장족의 발전이다. \n\n\n\n## STEP 2. 일단 뭐라도 작성한다. \n\n계정 이름을 정하는데 1일차를 보내버리고, 2일차가 되었다. 일단 티스토리 기본 세팅을 알려주고, 다른 무엇보다도 글을 몇개 써보라고 가이드 해 주었다. 티스토리의 메뉴에 대해서 간략히 설명하고, 글을 작성하는 에디터를 간략히 설명해 주었다. \n\n> 무엇이라도 좋으니, 일기 같은 글이라도 써 봐~\n\n일반 워드나 아래한글을 작성해 보았으니, 뭐 일반 글작성 에디터는 익숙 할 텐데, 문제가 발생하는 포인트는 그림 부분이었다. 그림 스크린 캡쳐/수정/복사 및 붙여 넣기를 어려워 했다. 일단은 어려움을 겪어야 Needs가 충만해 지기 때문에 잠시 놔두었다. 그러다가 물어보는 점을 집중적으로 알려 주었다. \n\n##### 대표적인 질문과 답변은 아래와 같았다\n\n1. <u>**이미지 2개를 병렬로 배치 (2열)하는 법**</u>\n\n   (답변) 이미지를 세로로 2개 붙여 넣고, 아래에 있는 그림을 드래그&드랍으로 위쪽 이미지의 바로 오른쪽으로 끌어다 놓으면, `빨강색 세로줄 가이드라인` 이 생김. 그 때 놓으면 자동으로 2열 배치됨 \n\n2. **<u>이미지 자르기 및 간략 수정, 이미지 위에 글씨 덧쓰는 방법 : 그림판 쓰면 되는거야?</u>**\n   (답변 1) 일단 그림판 써봐.. ^^;;; (한 두개 이미지 편집 후)\n   (답변 2) 많이들 사용하는 툴이 있어. 포토스케이프 (PhotoScapeX). 예전 포토샵 만큼 기능이 좋지는 않지만 블로그에 사용하기에는 딱이야. 포토스케이프를 설치해주고 간략히 사용법을 알려주었다. 나중에 포토스케이프 기능은 좀 더 본격적으로 알려줄 예정이다. (사실 필자도 사용하는 기능만 쓰는지라...)\n\n   ![image-20200515191903035](/Users/audit01/Library/Application Support/typora-user-images/image-20200515191903035.png)\n\n   > 포토스케이프 다운로드 : http://x.photoscape.org/\n\n3. **<u>(첫 번째 글) 이 거 다 작성 했어. 어떤것 같아...?</u>**\n\n   (답변 1) 첫번째 글 품질을 따지지 말고 일단 작성해. 방문자 수도 생각하지말고 글 쓰는 연습한다고 생각해~ \n\n   - 굳이 코멘트 하자면, 한줄 마다 단락 띄우지마. 가독성을 생각해.\n   - 모바일 화면으로 본다면, 이거 읽을 수 없어.\n\n나는 뭐 글을 잘써서 코멘트 하는 것은 아니지만, 먼저 경험해 본 입장에서 내가 느낀점을 알려 주었다. 역시, 처음 생각했던 것 처럼 블로거로써의 특징은 필자보다는 `와이프` 께서 더 능력이 있는 것 같다. ```뭐... IT쟁이가 글을 알면 얼마나 알겠는가 ㅜ_ㅜ```\n\n\n\n와이프님의 블로그 2일차 결과물은 아래와 같다. 와이프님께서 URL을 공개하면 `밥 없다~~` 라고 말씀하셔서, 일단 URL을 공개하지는 않는다. \n\n### 2일차 블로그\n\n![image-20200515185911757](/Users/audit01/Library/Application Support/typora-user-images/image-20200515185911757.png)\n\n\n\n## STEP 3\n\n3일차가 되었다. `와이프` 께서 이렇게 물으신다:\n\n> 왜 당신의 블로그는 구글검색에서 나오지 않냐고...? 헐~\n\n흐음. 블로그 생성한지 3일차인데, 구글검색에 노출되길 원하신다. 만약 이게 가능하다면 이미 `초고수` 반열이다. 그런데 큰일 났다. 생각해 보니 깜박 잊고 `와이프` 님의 블로그를 `구글서치콘솔`에 등록 조차 해두지 않았던 것이다. 누군들 이렇게 첫술에 배부를려고 할줄 알았으랴...\n\n\n\n## 구글서치콘솔(Google Search Console) 등록\n\n구글이든 네이버이든 웹검색엔진이 내 블로그 내용을 거져가(크롤링: crawling)해서, 잘 저장해 놓고(인덱신: Indexing), 누군가 키워드를 검색할 때 노출 시켜주어야 한다. 물론 검색 엔진들의 로봇(ex. googlebot)은 링크를 타고가서 이런 저런 글들을 읽어가지만, 우리는 의도적으로 최대한 블로그를 노출 시켜주기 위해서 명시적으로 내용을 가져가라고 등록해 준다. 이 과정이 각 검색엔진의 웹마스터도구에 정보를 등록해 주는 것이다. \n\n**구글(Google)**이 일일이 내 사이트/블로그를 뒤적거리고 다니지 않아도, 내가 미리 정보를 제공하는데, 파일 구조와 정보를 담아서 sitemap이라는 것을 만든다. 우리는 이것을 표준 포맷인 XML 형태로 만들어서 구글에 알려줄 것이다. 이 과정이 바로 구글 서치 콘솔에 정보를 등록하는 과정이다. 다행하게도, 최근 **구글서치콘솔**에 등록하는 과정을 티스토리(Tistory)에서 간소화 해주었다. 구슬서치콘솔 등록 플러그인을 사용하여 쉽게 등록 할 수 있다. \n\n> 다음(Daum) 검색엔진 등록 : 티스토리(Tistory) 동일 기업(다음카카오)에서 서비스하므로 자동으로 다음검색엔진에 등록해 준다.\n\n\n\n## 티스토리 플러그인 (Plugins)를 최대한 활용하자\n\n**앞에서 언급 했듯이, 티스토리는 플러그인으로 구글서치콘솔 (Google Search Console) 등록을 지원한다.** 별도 Google Search Console에 가서 개별 등록 및 설정하는 수고로움을 덜 수 있다. 이용할 수 있는 것은 최대한 이용해 주도록 하자. 티스토리의 \"관리메뉴 > 플러그인\" 메뉴로 이동하면, 다음과 같이 다양한 플러그인이 제공되고 있다. 이 중에서 구글서치콘솔(`Google Search Console`)  을 찾아서 클릭해 주자.\n\n### ![image-20200515180607097](/Users/audit01/Library/Application Support/typora-user-images/image-20200515180607097.png)\n\n\n\n**구글서치콘솔 플러그인**을 클릭하면 아래와 같은 팝업창을 뜨게 된다. 하단의 `설정 방법`을 참조하여 설정한다. 이미 구글 계정이 있다면 클릭 몇번만으로 설정이 가능하다. 설정 창을 누르면,팝업창이 하나 뜨며 구글 계정 로그인 및 권한 허용을 요구한다. **<u>특별히 위험한 권한은 없고 필요한 권한이므로 모두 허용 으로 클릭해 주면 된다.</u>** 상기 절차가 다 완료되면 최종적으로 티스토리 플러그인 메뉴에서 **적용 버튼**을 클릭해 주면 된다. \n\n![image-20200515181441588](/Users/audit01/Library/Application Support/typora-user-images/image-20200515181441588.png)\n\n\n\n## 구글서치콘솔 등록 확인 및 추가\n\n티스토리의 플러그인 설정이 끝나면, 구글서치콘솔에 방문해서 제대로 적용이 되었는지 재확인해 보도록 하자. 만약 플러그인이 제대로 등록되지 않았다면, 자신으 블로그는 검색이 되지 않을 것이므로 최종 적용 모습을 확인해 주자. `공부도 할 겸`\n\n**구글서치콘솔에 접속한다.** 구글검색창에 `구글서치콘솔`로 검색하거나, [구글서치콘솔URL](https://search.google.com/search-console) 직접 입력하여 구글서치콘솔로 접속한다. 로그인 후, 1) 좌측 메뉴들중 `Sitemaps` 를 누른다. 2) 우측 `제출된 사이트맵`에 자신의 웹사이트 URL이 제대로 등록되어 있는지 확인한다. 등록형식은 `https://xxxxx.tistory.com/sitemap.xml` 형태로 등록되어 있어야 한다. 여기에서 `xxxxx` 표기는 자신의 티스토리 계정명이다. 또는 개인 도메인을 가지고 있는 경우, 개인 도메인과 Sitemap.xml의 URL과 비교하여 정확한지 확인하면 된다. 나중에 티스토리 외, 추가적인 웹사이트를 개설하게 된다면, 여기에 웹사이트 URL과 sitemap.xml을 제출 하면 되니, 이점 기억하길 바란다. \n\n> 과거에는 sitemap.xml을 생성하여 구글서치콘솔에 등록해 주었어야 했으나, 최근 티스토리에서 sitemap 등록을 자동화 해 주었다. \n\n대부분의 경우, 제출된 사이트맵 항목이 1개일 것이다. 티스토리에서는 Sitemap.xml은 등록해 주지만, rss 피드는 등록해 주지 않기 때문ㅇ디ㅏ. rss를 추가로 등록해 주도록 하자.  상단에  `새 사이트맵 추가` 항목에 `https://xxxx.tistory.com/rss` 형식으로 써 준다음 `제출`버튼을 눌러준다.\n\n필자의 제출된 사이트맵은 아래와 같으니, 예로써 참고하길 바란다. \n\n```wiki\nhttps://richwind.co.kr/rss\nhttps://richwind.co.kr/sitemap.xml\n```\n\n![image-20200515181656808](/Users/audit01/Library/Application Support/typora-user-images/image-20200515181656808.png)\n\n\n\n앞서 언급했듯이, 다음(DAUM) 검색엔진에는 별도 웹마스터도구를 사용하지 않아도 알아서 등록해 준다. Tistory가 동일한 기업 서비스이니 자동으로 처리해 주는 것 같다. Daum 기준으로 동일 키워드(Keyword) 2순위까지 올라왔다. \n\n> 정말 예상 외이다. \n\n\n\n### 블로거 3일차, Daum 검색 키워드 2순위\n\n![image-20200515195550772](/Users/audit01/Library/Application Support/typora-user-images/image-20200515195550772.png)\n\n\n\n## 추가 옵션 : 네이버 웹마스터도구 등록\n\n다음/티스토리와는 경쟁 구도에 있는 네이버는 최근 티스토리를 블로그검색에서 제외하였다(검색결과를 블로그 항목에서 일반 웹사이트 항목으로 변경하였다.) 그럼에도 네이버는 국내 검색에서 탑검색엔진으로 간과할 수 없으므로 네이버 웹마스터도구에도 등록이 필요하다. [네이버 웹마스터 도구](https://searchadvisor.naver.com/)에 접속하여, 아래와 같이 사이트를 등록해 줄 필요가 있다. \n\n> 현 시점에서 필수 사항은 아닙니다. 나중에 검색엔진최적화 과정을 진행할 때 같이 할 겁니다.\n\n![image-20200515212401217](/Users/audit01/Library/Application Support/typora-user-images/image-20200515212401217.png)\n\n\n\n네이버 `Search Advisor` 서비스로 들어와 우측 상단에 `웹마스터 도구` 버튼을 눌러 줍니다. 웹마스터 도구에 **사이트 관리** 항목에서 사이트를 등록할 수 있습니다. 아래 필자의 경우, 필자의 사이트 URL `http://richwind.co.kr` 을 등록해 준 결과 입니다. \n\n![image-20200515193845166](/Users/audit01/Library/Application Support/typora-user-images/image-20200515193845166.png)\n\n추후 진행 예정입니다만, 메뉴중에 `간단체크` 항목으로 진입하면, 점검하고자 하는 사이트가 얼마나 구조화 및 최적화가 되었는진 항목점검해 주는 기능이 있습니다. 최소한 아래 기준 항목은 모두 만족을 해야 합니다. 현 시점에서 제 와이프 및 독자 여러분은 아래 항목에 만족을 못하는 항목도 존재 할 것입니다. \n\n\n\n![image-20200515212811107](/Users/audit01/Library/Application Support/typora-user-images/image-20200515212811107.png)\n\n\n\n\n\n\n\n\n\n\n\n","excerpt":"…","fields":{"slug":"/bloging-init-step-by-step/"},"frontmatter":{"date":"May 29, 2021","title":"컴알못 와이프, 블로거로 키우기 - 초보 블로거 따라하기 Step by Step","tags":["gatsby","blog"],"update":"May 29, 2021"}}},{"node":{"rawMarkdownBody":"\n![Gatsby Thumbnail Image](./images/gatsbyCover.png)\n\n\n\n# 블로그 만들기 2\n\n\ntest22\n\n","excerpt":"블로그 만들기 2 test22","fields":{"slug":"/gatsbyBlog_2/"},"frontmatter":{"date":"May 29, 2021","title":"gatsby 2","tags":["gatsby","blog"],"update":"May 29, 2021"}}},{"node":{"rawMarkdownBody":"\n![Gatsby Thumbnail Image](./images/gatsbyCover.png)\n\n\n\n# 블로그 만들기 3\n\nGatsby Blog 만들기 3\n\n\n\ntest22\n\n","excerpt":"블로그 만들기 3 Gatsby Blog 만들기 3 test22","fields":{"slug":"/gatsbyBlog_3/"},"frontmatter":{"date":"May 29, 2021","title":"gatsby 3","tags":["gatsby","blog"],"update":"May 29, 2021"}}},{"node":{"rawMarkdownBody":"\n# python TEST\n\n## folder test\n\nmd 파일이 한곳에 모여 있으면, image 등 파일관리가 쉽지 않을 수 있다. 따라서 폴더별로 다르게 하는 것도 하나의 방법이다. \n\n폴더를 카테고리별로 나누는 방법도 있을 수 있겠다. \n\n\n\n\n\n\n\n\n\n\n\n","excerpt":"python TEST folder test md 파일이 한곳에 모여 있으면, image 등 파일관리가 쉽지 않을 수 있다. 따라서 폴더별로 다르게 하는 것도 하나의 방법이다.  폴더를 카테고리별로 나누는 방법도 있을 수 있겠다.","fields":{"slug":"/python-test/"},"frontmatter":{"date":"May 29, 2021","title":"md file directory division test","tags":["blog","python","markdown"],"update":"May 29, 2021"}}},{"node":{"rawMarkdownBody":"\n\n\n\n\n[toc]\n\n\n\n\n\n\n\n# Python\n\n\n\n## Bash command execution\n\n\n\n다음은 파일명에서 \"CPU\"라는 문자열을 포함한 파일만을 출력하여 준다. \n\n```bash\n$ ls | grep CPU\n```\n\n어떠한 대용량 데이터가 특정조건에 따라 파일로 작게 나뉘어 있는 경우가 있는데, 특정 조건으로만 파일을 불러들여 처리하는 경우가 종종 발생한다. 실제로 필자는 CPU 관련한 데이터를 기록한 xml을 개별로 취급할 때 사용하였다. \n\n\n\n```bash\n~/my_dev/ai_secu2020/src\n$ ls ../data/NMS10_XMLs | grep CPU\nFW_12348573_125.57-N_CPU.xml\nFW_12348584_172.18-N_CPU.xml\n  ...\n```\n\n\n\n### sed 를 이용한 문자열 치환 \n\n필자는 데이터 전처리의 초기 단계에서 종종 bash command를 사용한다. 대표적으로 sed, cut, awk 등의 명령어가 있다. sed는 쉽고 빠르게 io만을 이용하여 문자열을 치환해 준다. 복잡하지 않은 단순 치환이라면 sed명령어는 매우 유용하다고 할 수 있다. 문자열을 취급하다보면, 개행문자(`\\n`) 등의 command 문자나, 빈칸 (White Space)제거 또는 주석(Commet) 제거 등이 자주 사용된다. \n\n\n\n파일명 등 bash 에서 취급하는 문자열의 처리에 유용할 뿐만 아니라, 실제 Contents 처리에도 유용하다. \n\n```bash\n$ cat sample.txt | sed 's/\\n//g'\n```\n\n> 개행문자(`\\n`)을 ''으로 치환한다. 즉, 개행문자를 삭제한다. \n\n\n\n만약 `Jupiter notebook` 또는 IPython을 사용한다면, `%`  또는 `!`을 사용하여 bash command를 실행할 수 있다. \n\n```python\n% cat sample.txt | sed 's/\\n//g'\n```\n\n\n\n다음과 같이 **Python** 으로 python을 직접 파일을 읽어서, 문자열을 처리하는 방법도 있으나, 데이터의 양이 많거나, 파일이 여러개인 경우 bash 명령어로 처리한다면 쉽게 동일 작업을 수행할 수 있다. \n\n```python\nprint(open('sample.txt', 'r').read().replace('#',''))\n```\n\n> sed를 사용하는 방법은 매우 간편할 뿐만 아니라, Bash 명령어를 사용하여 새롭게 치환된 파일을 생성하면, 실제 데이터를 처리하는 python 모듈의 메모리를 절약할 수 있다. \n\n\n\n물론 파이썬으로 처리하면, 하나의 py파일에서 일관되게 처리를 할 수 있는 장정도 있다. 그러나, 적용해야하는 파일이 다수개인 경우 역시나 bash 명령어가 편하다. \n\n```bash\nls | grep CPU | xargs sed 's/\\n//g'\n```\n\n> 현재 working directory 에 존재하는 파일중, 파일명에 CPU가 포함되어 있는 파일을 대상으로, 모든 개행문자를 제거한다. \n\n\n\n다음은 bash script의 for문을 활용하여, 모든 파일에 대하여 실행한 sed 결과를 새로운 파일(`modify-<기존파일명>`)에 저장한다. \n\n```bash\nfor filename in $(ls | grep CPU); do\n  sed 's/\\n//g' $filename > modify-$filename\ndone\n```\n\n\n\npython으로 관리하는 프로젝트에서 bash script까지 별도로 진행되기 때문에 관리의 불편함을 느낄 수도 있다. 이라한 경우, bash script의 관리가 불편하다면, bash script 파일을 하나 만들어 두고, script 파일의 실행만을 python으로 진행하면 된다. \n\n\n\n혹시, 이것도 관리가 번거롭다면, 다음과 같이 python 자체에서 bash script를 만들어 주고, 실행해 주면 된다. \n\n```python\nimport os\n\nstrDataPath = './data'\nstrScript =\"\"\"\n#!/bin/bash\ncd {}\nfor filename in $(ls | grep CPU); do\n   sed 's/\\n//g' $filename > modify-$filename\ndone\ncd -\n\"\"\".format(strDataPath, strMode)\nwith open('modifyScript.sh','wt') as fp:\n    fp.write(strScript)\n\nos.system('chmod +x modifyScript.sh')\nos.system('./modifyScript.sh')\n```\n\n> current directory 와 다른 path에서 작업을 하고 싶다면, cd <path>를 수행하여 directory를 변경하고, `cd -` 명령을 통해서 원래의 directory로 복귀할 수 있다. \n\nPython의 이슈는 아니지만, 주의할 사항으로 스크립트파일(ex. `script.sh`)을 생성하고 난 후 실행 권한 ( `+x`)을 부여해 주는 것을 간과하기 쉬우므로 유의하기 바란다. 스크립트 파일을 생성하고, 실행권한을 부여 후 `os.system()`함수로 실제 스크립트를 구동해 준다. \n\n\n\n### Python CMD/프로세스 실행\n\n\n\nPython에서 외부 프로세스 실행하는 방법은 크게 3가지 방법이 있다. \n\n#### os.system()\n\npython에서 shell 명령어를 실행하기에 가장 단순하고 편리한 방법은 system() 함수를 사용하는 방법이다. \n\n`os.system( '명령어' )` 형태로 실행할 수 있다. 간단한 스크립트를 실행하거나, 또다른 python을 구동할 때, 서비스를 구동 시킬 때 등 사용할 수 있다. 다음과 같은 예제를 들어 볼 수 있다. \n\n```python\nos.system('chmod +x test.sh')\n```\n\n그러나, os.system()은 실행 결과에 대한 실행여부만 반환해 준다. 정상 실행은 `0` , 비정상 실행은 `에러코드값`을 반환해 준다. 대표적으로, `ls` 명령어로 현재 디렉토리의 파일 리스트를 확인할 수 없다.  다음과 같이 실행은 할수 있다. \n\n```python\nos.system('ls')\n==> 결과값 : 0\n```\n\n> 실행은 해준다. 그러나 결과값을 확인 할 수 없다.\n>\n> Ipython 또는 jupyter notebook 사용자라면, magic command(`%명령어`)로 단순하게 실행도 가능하다. ex.  `%ls`\n\n\n\n#### os.popen()\n\n문제를 단순화 해서, python 내부에서는 어떻게 `ls 명령어`의 실행 결과를 확인하고, 결과값들을 저장할 수 있는가? `os.system()`은 결과값을 반환해 주지는 않기 때문에 다른 명령어가 필요하다. \n\n`os.popen()`함수는 결과값을 반환해 준다. 좀 더 자세하게, 결과값보다는 실행하는 handle 또는 file descriptor를 반환해 준다. 따라서, os.system()함수처럼 호출하는 즉시 실행되는 것보다는, 실행구문을 지정하고 이후 read를 할 때 실행되는 구조이다. 함수의 이름에서 추측할 수 있듯이 `open`계열의 함수 이다. 파일을 오픈하는 것과 동일하게 Process를 open하는 개념이다. linux 계열의 kernel은 모든 것을 file로 보듯이, fd(file descriptor)로서 process를 오픈/실행하는 것으로 생각해 볼 수있다. 어찌 보면, lazy execution과 비슷한 방식이라고도 할 수 있다. \n\n```python\ncmd = os.popen('ls')\nval = cmd.readlines()\n```\n\n> os.popen()을 실행하는 시점에 명령어가 수행되는 것은 아니다. 오히려 `cmd.readlines()` 시점에서 명령어가 실행된다. \n\n\n\n다음은 필자가 실제 사용하고 있는 코드중 일부를 발췌하였다. 파일 들중에서 `CPU` 문자열을 포함한 파일만을 선별하여 파일명을 얻어오는 과정이다.\n\n```python\nstrDataPath = '../data/NMS10_XMLs/'\nstrCmd = \"ls {} | grep CPU\".format(strDataPath)\nstrFile = [x.strip() for x in os.popen(strCmd).readlines()]\nprint(strFile)\n```\n\n\n\n#### subprocess 실행 방법\n\nos 모듈은 기본적으로 os에서 제공하는 기능을 사용하는 모듈이다. 좀 더 전문적으로 process자체를 다루기 위해서 `subprocess` 모듈을 제공하고 있다. 단순히 명령어를 실행해 준다는 개념보다는 process를 다루는 개념이며, 이중에서 process를 실행해서 결과를 받아오는 함수가 일부 포함되어 있는 것이다. 좀 더 하위 레벨에서 process와 thread 등을 다룰 때 사용할 수 있다. \n\n`os.system()`는 동일 process에서 명령을 수행 후 종료하지만, `subprocess` 에 포함된 함수는 새로운 child process를 생성하여 실행한다. (fork) . 따라서, process 실행에 대한 상세 argument 들을 제어할 수 있다. \n\n> 실행의 반환값은 CompletedProcess 개체이다. CompoletedProcess는 기본적으로 args, returncode, stdout, stderr를 포함하며, stdout과 stderr는 None을 기본값으로 한다. \n\n\n\n```python\nimport subprocess\nr = subprocess.run('ls')\nprint(r)\n```\n\n> 결과는 실행코드이다. 성공:0, 에러:1\n\n\n\n기본적으로 stdout, stderr는 capture하지 않는다. (capture_otput=False) stdout을 확인하기 위해서는 caputre=True로 변경해 준다.  다음을 실행해 보자.\n\n```python\nimport subprocess\nr = subprocess.run('ls', capture_output=True )\nprint(r)\nprint(r.stdout)\n```\n\n\nsubprocess는 low level function으로 실행결과가 bytes 라는 점에 유의가 필요하다. 이러한 이유로, `utf-8`의 bytes를 string으로 디코딩(decode)해줄 필요가 있다. 다음은 명령어 실행 결과로 얻은 최종 문자열의 리스트 이다. \n\n```python\nfileList = [x.decode('utf-8') for x in r.stdout.splitlines()]\n```\n\n\n\n바이트 (utf-8로 인코딩된 byte)를 문자열로 변환하는 과정은 다음은 참조하기 바란다. \n\n###### Byte to String\n\n```python\na = b'AAAA\\n'\nb = a.decode('utf-8')\nprint(a)\nprint(b)\n```\n\n\n\n#### IPython Magic Command\n\n외부 명령어 실행까지는 아니지만 shell command 명령어로 한정한다면, Ipython 의 매직 커맨드 (magic command)를 활용할 수 있다. 앞서 잠깐 언급했듯이 ipython 또는 jupyter notebook 환경에서는 몇몇 매직커맨드를 제공하고 있다. 이중에서 shell command 실행을 지원하는 기능이 포함되어 있다.  다음과 같이 png 이미지 파일 리스트를 바로 확인 할 수 있다.\n\n```python\n%ls | grep png\n```\n\n그러나 이와 같은 겨우, notebook의 cell에서 결과 확인은 가능하나, 여러개의 파일을 자동화 처리하기 위해서는 변수로 저장해야 한다. 이와 같은 경우 기본 매직커맨드 (`%`) 구문 대신 `!`를 사용하여 결과 같을 변수로 저장할 수 있다. \n\n```python\nr = !ls | grep png\nprint(r)\n```\n\n\n\n#### 기타 python os 모듈기능\n\n앞서 설명한 방법들은 외부 명령어 실행에 대한 범용적인 방법이다. 그러나, python의 os모듈에는 자주 사용하는 shell 명령어 들을 이미 함수로 제공하고 있다. listdir(), makedir(), chdir() 등이 대표적인 예라 할 수 있다. 다음 명령어 라인을 참조하기 바란다. \n\n```python\nos.listdir() # list dir\nos.makedirs() # make a dir\nos.rmdir()   # remove a dir\nos.rename()  # rename a old one to  a new one\n\nos.path\nos.path.exists( <파일 또는 디렉토리명> )  # check if it exists\nos.path.isdir()  # check if it is a directory\nos.path.isfile() # check if it is a file\nos.getcwd() # get current dir\nos.chdir()  # change dir\n```\n\n\n\n경우에 따라서는, python에서 외부 명령어를 실행할 때, 환경변수가 필요한 경우가 있다. `os.environ`은 환경변수를 설정을 지원한다. \n\n```python\nenv = os.environ\nenv['PATH']\npath2 = r'<add path dir>;' + env['PATH'] \nenv['PATH'] = path2\n```\n\n> 환경변수의 설정은 현재 open된 창에만 적용된다. (메모리에만 존재한다. )\n\n\n\n#### 응용\n\n##### 디렉토리 부재 시 디렉토리 생성\n\n개발을 진행하다 보면, 경우에 따라서 subdirectory를 사용하게 된다. 데이터를 참조하거나 저장할 때 sub-directory를 사용하는 경우도 많다. 로직의 흐름에 따라서 sub-directory가 존재하지 않는 경우도 발생하는데, 이런 경우 디렉토리 존재 여부를 확인하고 생성해 줄 필요가 있다. \n\n다음은 현재 디렉토리를 기준으로  `../dev/img` 디렉토리가 존재하는지 확인 후, 해당 디렉토리가 없다면 디렉토리를 생성한다. \n\n```python\n# path check and make dir\nstrPath = '../dev'\nrePath = \"{}/img\".format(strPath)\nif not os.path.exists(rePath ):\n    os.makedirs(rePath)\n```\n\n\n\n\n\n\n\n---\n\n\n\n## XML Parsing\n\n\n\n우선 xml 파싱하는 기본 구문부터 살펴 보자. \n\n```python\nimport xml.etree.ElementTree as eTree \n\nxmlTree = eTree.parse('./test.xml')\ndata = xmlTree.findall('./rra')\n\n```\n\n`xml.etree.ElementTree` 모듈에 있는 `parse`함수를 사용하면, xml을 손쉽게 로딩할 수 있다. Xml을 파싱하여 얻은 개체에서 find / findall 등의 명령어를 사용하여 하위 tag를 개체로 가져올 수 있다. 좀 더 상세한 내용을 알아보기 전에, 분석해야하는 샘플 xml의 구조를 확인하고 진행하도록 하자. \n\n\n\n파싱하고자 하는 XML의 파일 구조는 다음과 같은 구조를 가지고 있다. 데이터에 관련한 속성(property)를 가지고 있으며, 주요 데이터값은 `RRA-> Database -> row -> v` 에 데이터가 행으로 보유하고 있는 형식이다. \n\n```mermaid\ngraph LR\nclassDef dotOutline fill:#f96,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5, 5\nRRD --> version\nRRD --> step\nRRD --> lastUpdate\nRRD --> RRA:::dotOutline\n\nRRA --> cf\nRRA --> pdp_per_row\nRRA --> database:::dotOutline\n\ndatabase --> date\ndatabase --> time\ndatabase --> row:::dotOutline\nrow --> v :::dotOutline\n\n```\n\n다음은 파싱(Parsing) 하고자하는 실제 xml 파일의 일부를 발췌한 문서이다. \n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE rrd SYSTEM \"http://oss.oetiker.ch/rrdtool/rrdtool.dtd\">\n<!-- Round Robin Database Dump -->\n<rrd>\n\t<version>0003</version>\n\t<step>60</step> <!-- Seconds -->\n\t<lastupdate>1441253228</lastupdate> <!-- 2015-09-03 13:07:08 KST -->\n\t<!-- Round Robin Archives -->\n\t<rra>\n\t\t<cf>AVERAGE</cf>\n\t\t<pdp_per_row>1</pdp_per_row> <!-- 60 seconds -->\n\t\t<database>\n\t\t\t<date>2015-09-01 13:08:00</date><time>1441080480</time> <row><v>2.0000000000e+00</v></row>\n\t\t\t<date>2015-09-01 13:09:00</date><time>1441080540</time> <row><v>2.0000000000e+00</v></row>\n\t\t\t<date>2015-09-01 13:12:00</date><time>1441080720</time> <row><v>2.0000000000e+00</v></row>\n    </database>\n  </rra>\n</rrd>\n</\n```\n\n\n\n\n\n\n\n\n\n\n\n# test 01\n\n\n\n\n\n\n\n\n\n","excerpt":"toc Python Bash command execution 다음은 파일명에서 \"CPU…","fields":{"slug":"/python-EDA-001/"},"frontmatter":{"date":"May 29, 2021","title":"Python EDA","tags":["blog","python","markdown"],"update":"May 29, 2021"}}},{"node":{"rawMarkdownBody":"\n\n[toc]\n\n\n\n\n\n# Python Basic\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 파이썬 기본 문법\n\n\n\n자료형\n\n\n\n제어문\n\n\n\n반복문\n\n\n\n함수와 클래스\n\n\n\n모듈과 패키지\n\n\n\n파일 입출력\n\n\n\n# 문자열 다루기\n\n\n\n\n\n## 문자열 출력하기 \n\n문자열 출력 방법\n\n- print()\n\n- ## 문자열 포매팅\n\n- string.format()\n\n- f\" 문자열 \" \n\n\n\n```python\na = \"abcd\"\nb = \"1234\"\nprint(\"this is \"+ a)\nprint(\"this is \", a)\nprint(\"this is {} \".format(a))\nprint(\"this is {} and {} \".format(a,b))\nprint(\"this is {0} and {1} \".format(a,b))\nprint(\"this is {0} and {1}, {0} \".format(a,b))\n\nprint(f\"this is {a} and {b}\")\n\n\n```\n\n\n\n\n\n\n\n\n# 데이터 분석\n\n\n\n## 데이터분석 1 : NumPy\n\n\n\n\n\n\n\n\n\n\n\n## 데이터 분석 2 : Matplotlib \n\n\n\n\n\n\n\n\n\n## 데이터 분석 3 : SciPy\n\n\n\n\n\n\n\n## 데이터 분석 4 : Pandas \n\n\n\n\n\n\n\n### 엑셀 다루기\n\npython 에서 스프레드시트 (Excel Spread Sheet)를 다루는 모듈. Xlwt, xlsxwriter, openpyxl\n\n- openpyxl : anaconda 배포본에 기본 탑재\n\n\n\n\n\nExcel 데이터를 clipboard 복사 후 사용하기\n\n\n\n```python\nimport numpy as np\nimport pandas as pd\ndf = pd.read_clipboard()\ndf['name'].as_matrix()\n```\n\n\n\n\n\n\n\n### Xml 다루기\n\n\n\n\n\n# 파이썬 고급(Python Advance)\n\n\n\n\n\n## 정규표현식 사용 (Regular Expression)\n\n\n\n\n\n\n\n## TTS (Text to Speech)\n\n\n\n### Google TTS\n\n\n\n#### 구글 TTS 설치\n\n```bash\n$ pip install gTTS\n```\n\n\n\n#### Quick start\n\n```bash\n$ gtts-cli 'hello' --output hello.mp3\n```\n\n\n\n#### python code\n\n```python\nfrom gtts import gTTS\ntts = gTTS('hello. this is the first application')\ntts.save('hello.mp3')\n```\n\n\n\n## 오디오/mp3 재생 (Multimedia play) \n\n\n\n\n\n### Mpg321\n\npython의 기본 모듈 (pyaudio 등)에는 mp3 코덱이 포함되어 있지 않다. 아마도 mp3 라이선스 문제일 것으로 예상된다. 따라서, mp3 와 같은 오디오 재생은 별도의 모듈의 설치가 필요하다. 필자가 사용한 오디오 모듈 중 안정성과 편의성을 고려하여 가장 쉬운 모듈은 `mpyg321`이었다. \n\nmpg321은 가장 단순하면서도 인기가 높은 커맨드라인 (command-line) mp3 플레이어(player) 이다. 명령어줄(command line)에서 `mpg321 파일명.mp3` 입력만으로 mp3를 재생할 수 있다. \n\n> GNU License v.2 (Gerneal Public License v.2)\n\n\n`mpyg321`은 공용 라이브러리인 mpg321을 python으로 감싸놓은 모듈이다. 따라서, mpg321모듈을 먼저 설치하고, mpyg321을 설치한다. \n\n\n\n#### MacOS\n\n```bash\n$ brew install mpg321\n$ pip install mpyg321\n```\n\n\n\n#### Linux\n\n```bash\n$ sudo apt-get install mpg321\n$ pip3 install mpyg321\n```\n\n\n\n#### Windows\n\n```bash\n$ pip install mpyg321\n```\n\n\n\n#### 명령어 라인 사용법\n\n```bash\n$ mpg321 <mp3파일명>\n    or \n$ mpg321 -q <mp3파일명>\n```\n\n> `-q` 옵션은 quite mode 이다.\n\n\n\n#### 파이썬(Python) 코드 사용법\n\n```python\nfrom mpyg321.mpyg321 import MPyg321Player()\nplayer = MPyg321Player()\nplayer.play_song(\"/path/to/some_mp3.mp3\")\n```\n\n> 참조 : https://pypi.org/project/mpyg321/\n\n\n\n또 다른 형태로는, 커멘드라인 구문을 바로 실행 시키는 방법이 있다. \n\n```python\nimport subprocess\nsubprocess.Popen(['mpg321', '-q', path]).wait()\n```\n\n좀 더 단순한 방법으로는 다음과 같은 구문이라 하겠다. \n\n```python\nimport os\nos.system('mpg321 -q '+ path)\n\t    or \nr = os.popen('mpg321 -q '+ path)\n```\n\n\n\n\n\n## pygame \n\n2번째 방법은 pygame 모듈을 사용하는 방법이다. \n\n```bash\n$ pip install pygame\n```\n\n\n\n```python\nfrom pygame import mixer\n\nmixer.init()\nmixer.music.load('hello.mp3')\nmixer.music.play()\n```\n\n\n\n\n\n## GUI 다루기\n\n\n\n\n\n\n\n\n\n# Appendix.1 환경 설정\n\n\n\n## 설치와 구동\n\n\n\n## 개발환경\n\n\n\n### Jupyter notebook\n\n\n\n### Visual Studio Code\n\n\n\n## 가상환경\n\n\n\n### virtual envs\n\n\n\n### kernels\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","excerpt":"toc Python Basic 파이썬 기본 문법 자료형 제어문 반복문 함수와 클래스 모듈과 패키지 파일 입출력 문자열 다루기 문자열 출력하기 문자열 출력 방법 print() 문자열 포매팅 string.format() f…","fields":{"slug":"/python-basic/"},"frontmatter":{"date":"May 29, 2021","title":"실전 예제로 배우는 파이썬 기본 (Python Basic) - 가장 빠르게 배우는 파이썬","tags":["python","markdown"],"update":"May 29, 2021"}}},{"node":{"rawMarkdownBody":"\n![Gatsby Thumbnail Image](./gatsbyCover.png)\n\n\n\n# 블로그 만들기\n\n\n기존에 Naver Blog, Tistory Blog를 사용하다가 github를 사용하여 개인 블로그를 만들게 되었습니다. Github에서 제공하는 Publish 방법인 Github Page와 정적 웹페이지 생성기인 Gatsby를 사용하였습니다. Gatsby로 별도 블로그를 만들어야지 하는 생각은 오래전 부터 있었는데, 미뤄 두었다가 이제서야 생성했네요.\n\nGatsby 는 다른 분이 만들어 놓은 테마를 수정해서 사용했습니다. \n\nGithub Page Setting이 의외로 시간이 걸렸습니다. \n\nCustom DNS 세팅을 하는데,\nsubdomain으로 하면, CNAME으로만 등록해야 되네요.\nIT만 20년이 넘게 일했는데, DNS 세팅을 하다가 실제로 써보면서 배우는점이 아직도 많네요.\n역시 해보면서 배우나 봅니다. \n\n기존에 블로그들의 스킨들로 스트레스 받은 것을 날려버리고,\n이제 좀 글에만 집중을 하고 싶습니다. \n\n## Markdown 글쓰기\n\n개인적을markdown 위주로 글쓰기에 가장 고민 스러운 부분이 2가지가 있습니다. \n- 1) 이미지 삽입의 불편성 \n- 2) 색상 변경 불가\n\n### 이미지 삽입의 불편함\n블로그를 작성하다 보면 이미지 삽입이 자주 발생합니다. ***특히, 화면캡쳐 후 바로 삽입 같은 경우입니다.*** 그런데, 마크다운을 사용하여 블로그를 작성하면, 이미지를 파일로 저장하고 저장된 이미지를 path를 걸어서 사용하는 불편함이 있습니다. 블로그를 운영해 본 분은 잘 아시겠지만 이미지가 한두장도 아니고 일일이 이렇게 처리하기에는 무척 번거롭습니다. 현재 이 때문에 이미지 붙여 넣기에 특화된 마크다운 에디터 `typora`를 사용중입니다만, 제 마음 같지 않네요. \n\n이 부분은 좀 더 편한 방법을 좀 고민해봐야 겠습니다. \n\n### <span class='markdown-head'>글자 색상 변경 </span>\n원칙적으로 마크다운은 글자 색상 지정이 없습니다. 꼼수로 HTML 태그를 끼워넣어 색상을 표현하는 경우도 있긴 합니다. 그런데, 어차피 마크다운으로 넘어온 이유가 글의 일관된 템플릿으로 사용하기 위함이 었기 때문에, 자유도가 높을 필요는 없을 것 같습니다. \n그러나, 색상 자체가 1개 단일색 이라는 것은 참.. 단조롭긴 합니다.  1~2개의 색상만이라도 추가적으로 사용할 수 있으면 합니다. \n\n따라서, 마크다운 자체가 아니라, 마크다운을 파싱하고 난 다음 마크다운 파싱을 html로 옮겨올 때 설정으로 미리 지정된 색상을 끼워 넣어 볼가 합니다. \n이부분은 추가적인 연구가 좀 필요하겠습니다. \n이런 과정을 미리 겪어보신 분이 있다면 의견 부탁 드립니다. \n\n### 추가 고민\n\n> 아직 걱정할 일은 아닙니다만, Github 용량을 이미지만으로 채울 수 없으니,\nimage cdn 도는 AWS S3에 저장해 놓고 링크만 걸어야 할지도 고민중입니다.\n\n일단, Github로 운영을 좀 해보다가, 다른 frontend 서비스로 변경해야 할지는 차차 고민해 볼 예정입니다. \n<span style=\"font-family:Papyrus\">ex) Netlify, AWS CloudFront, AWS Amplify, 등..</span>\n\n[블로그](https://richwind.co.kr)\n\n\n<style>\n      .markdown-body {\n        font-size:10em;\n          box-sizing: border-box;\n          min-width: 100px;\n          max-width: 980px;\n          margin: 0 auto;\n          padding: 15px;\n      }\n      .markdown-head {\n        color:red;\n        font-size:2em;\n        font-family:Papyrus;\n      }\n      h2 {\n        color : blue;\n      }\n      h1 {\n        color : skyblue;\n      }\n  </style>","excerpt":"블로그 만들기 기존에 Naver Blog, Tistory Blog를 사용하다가 github를 사용하여 개인 블로그를 만들게 되었습니다. Github에서 제공하는 Publish 방법인 Github Page와 정적 웹페이지 생성기인 Gatsby…","fields":{"slug":"/how-to-make-gatsby-blog/"},"frontmatter":{"date":"Jun 06, 2020","title":"how to make blog with the gatsby","tags":["gatsby","blog"],"update":"Jun 07, 2020"}}},{"node":{"rawMarkdownBody":"\n![](screenshot.png)\n\n이미지 파일이 첨부된 게시물의 예제입니다.\n\n폴더를 만들고 폴더의 제목이 해당 게시물의 주소가 됩니다.\n\n게시물 파일명은 index.md 로 합니다.\n\n이미지 파일은 폴더 내에 위치시킵니다.\n\n자세한 가이드는 [Documents](<https://github.com/junhobaik/junhobaik.github.io/wiki/Document-(Borderless)>)를 확인해주세요.\n","excerpt":"이미지 파일이 첨부된 게시물의 예제입니다. 폴더를 만들고 폴더의 제목이 해당 게시물의 주소가 됩니다. 게시물 파일명은 index.md 로 합니다. 이미지 파일은 폴더 내에 위치시킵니다. 자세한 가이드는 Documents를 확인해주세요.","fields":{"slug":"/image-post-example.md/"},"frontmatter":{"date":"Mar 24, 1991","title":"Image, 이미지 게시물 예제","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n게시물에 태그를 지정할 수 있습니다.\n\n해당 게시물의 Markdown YAML Front matter은 아래와 같습니다.\n\n```\n---\ntitle: Tag, 태그 게시물 예제\ndate: 2019-07-30\ntags:\n  - tag\n  - 태그\n---\n```\n\n가이드의 Markdown YAML Front matter를 참고하세요.\n\n자세한 가이드는 [Documents](<https://github.com/junhobaik/junhobaik.github.io/wiki/Document-(Borderless)>)를 확인해주세요.\n","excerpt":"게시물에 태그를 지정할 수 있습니다. 해당 게시물의 Markdown YAML Front matter은 아래와 같습니다. 가이드의 Markdown YAML Front matter를 참고하세요. 자세한 가이드는 Documents를 확인해주세요.","fields":{"slug":"/tag-post-example/"},"frontmatter":{"date":"Mar 24, 1991","title":"Tag, 태그 게시물 예제","tags":["tag","태그"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n블로그를 본인에 맞춰 커스터마이징하려면 우선 config.js의 수정이 필요합니다.\n\n[Documents](<https://github.com/junhobaik/junhobaik.github.io/wiki/Document-(Borderless)>)를 확인해주세요.\n","excerpt":"블로그를 본인에 맞춰 커스터마이징하려면 우선 config.js의 수정이 필요합니다. Documents를 확인해주세요.","fields":{"slug":"/first-post/"},"frontmatter":{"date":"Mar 23, 1991","title":"Borderless Documents","tags":["test","blog"],"update":"Mar 08, 2020"}}}]}},"pageContext":{}},"staticQueryHashes":["3649515864","3998623811","63159454"]}